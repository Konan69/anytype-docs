"use strict";(self.webpackChunkanytype_docs=self.webpackChunkanytype_docs||[]).push([[427],{3379:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"integration/frontend_backend","title":"Frontend-Backend Integration: Technical Implementation Analysis","description":"Detailed technical analysis of how Anytype\'s frontend and backend components integrate and communicate","source":"@site/docs/integration/frontend_backend.md","sourceDirName":"integration","slug":"/integration/frontend_backend","permalink":"/anytype-docs/docs/integration/frontend_backend","draft":false,"unlisted":false,"editUrl":"https://github.com/konan69/anytype-docs/tree/main/docs/integration/frontend_backend.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Frontend-Backend Integration: Technical Implementation Analysis","description":"Detailed technical analysis of how Anytype\'s frontend and backend components integrate and communicate","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Integration","permalink":"/anytype-docs/docs/integration/"}}');var r=t(4848),i=t(8453);const a={title:"Frontend-Backend Integration: Technical Implementation Analysis",description:"Detailed technical analysis of how Anytype's frontend and backend components integrate and communicate",sidebar_position:2},o="Frontend-Backend Integration: Technical Implementation Analysis",c={},d=[{value:"Overview",id:"overview",level:2},{value:"Integration Architecture",id:"integration-architecture",level:2},{value:"Key Integration Mechanisms",id:"key-integration-mechanisms",level:2},{value:"1. Binary Embedding",id:"1-binary-embedding",level:3},{value:"2. Inter-Process Communication (IPC)",id:"2-inter-process-communication-ipc",level:3},{value:"Frontend IPC Implementation",id:"frontend-ipc-implementation",level:4},{value:"Backend IPC Implementation",id:"backend-ipc-implementation",level:4},{value:"3. Command Pattern",id:"3-command-pattern",level:3},{value:"4. Event System",id:"4-event-system",level:3},{value:"Event Dispatcher",id:"event-dispatcher",level:4},{value:"Event Subscription",id:"event-subscription",level:4},{value:"5. Data Mappers",id:"5-data-mappers",level:3},{value:"Data Flow Examples",id:"data-flow-examples",level:2},{value:"1. Creating a Block",id:"1-creating-a-block",level:3},{value:"2. Subscribing to Object Changes",id:"2-subscribing-to-object-changes",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Integration with Sync Infrastructure",id:"integration-with-sync-infrastructure",level:2},{value:"Key Insights",id:"key-insights",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"frontend-backend-integration-technical-implementation-analysis",children:"Frontend-Backend Integration: Technical Implementation Analysis"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Anytype's architecture employs a clear separation between the frontend (anytype-ts) and the backend (anytype-heart) components. The frontend is built as an Electron application using TypeScript, React, and MobX, while the backend is implemented in Go. These components communicate through a sophisticated integration layer that enables seamless interaction while maintaining separation of concerns."}),"\n",(0,r.jsx)(n.h2,{id:"integration-architecture",children:"Integration Architecture"}),"\n",(0,r.jsx)(n.p,{children:"The integration between frontend and backend follows this high-level architecture:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"+-----------------------------------------------------------+\n|                   ANYTYPE-TS (FRONTEND)                   |\n|                                                           |\n|  +---------------+    +------------+    +-------------+   |\n|  |               |    |            |    |             |   |\n|  |  React UI     |---\x3e|  MobX      |---\x3e|  API Layer  |   |\n|  |  Components   |<---|  Stores    |<---|  (IPC)      |   |\n|  |               |    |            |    |             |   |\n|  +---------------+    +------------+    +------+------+   |\n|                                                |          |\n+------------------------------------------------|----------+\n                                                 |\n                                                 | IPC\n                                                 |\n+------------------------------------------------|----------+\n|                                                |          |\n|  +------+------+    +-------------+    +------+------+   |\n|  |             |    |             |    |             |   |\n|  |  IPC        |---\x3e|  Service    |---\x3e|  Core       |   |\n|  |  Handler    |<---|  Layer      |<---|  Services   |   |\n|  |             |    |             |    |             |   |\n|  +-------------+    +-------------+    +-------------+   |\n|                                                           |\n|                   ANYTYPE-HEART (BACKEND)                 |\n+-----------------------------------------------------------+\n"})}),"\n",(0,r.jsx)(n.h2,{id:"key-integration-mechanisms",children:"Key Integration Mechanisms"}),"\n",(0,r.jsx)(n.h3,{id:"1-binary-embedding",children:"1. Binary Embedding"}),"\n",(0,r.jsx)(n.p,{children:"The anytype-heart backend is compiled into a binary and embedded within the anytype-ts frontend application:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"anytype-ts/\n\u251c\u2500\u2500 dist/\n\u2502   \u2514\u2500\u2500 anytypeHelper     # Compiled anytype-heart binary\n"})}),"\n",(0,r.jsx)(n.p,{children:"This embedded binary is launched by the Electron application when it starts:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// In electron.js\nconst binPath = fixPathForAsarUnpack(\n  path.join(__dirname, "dist", `anytypeHelper${is.windows ? ".exe" : ""}`)\n);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-inter-process-communication-ipc",children:"2. Inter-Process Communication (IPC)"}),"\n",(0,r.jsx)(n.p,{children:"Communication between frontend and backend occurs through Electron's IPC mechanism. The frontend sends commands to the backend and receives responses asynchronously:"}),"\n",(0,r.jsx)(n.h4,{id:"frontend-ipc-implementation",children:"Frontend IPC Implementation"}),"\n",(0,r.jsxs)(n.p,{children:["The frontend implements an API layer in ",(0,r.jsx)(n.code,{children:"src/ts/lib/api/"})," that abstracts the IPC communication:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Simplified renderer.ts\nclass Renderer {\n  send(...args: any[]) {\n    const cmd = args[0];\n    const electron = U.Common.getElectron();\n    const currentWindow = electron.currentWindow();\n    const winId = Number(currentWindow?.windowId) || 0;\n\n    args.shift();\n    args = args.map((it: any) => {\n      if ("undefined" == typeof it || it === null) {\n        it = "";\n      }\n      return it;\n    });\n\n    return electron.Api(winId, cmd, U.Common.objectCopy(args));\n  }\n\n  on(event: string, callBack: any) {\n    this.remove(event);\n    U.Common.getElectron().on(event, (...args: any[]) =>\n      callBack.apply(this, args)\n    );\n  }\n\n  remove(event: string) {\n    U.Common.getElectron().removeAllListeners(event);\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"The Electron preload script exposes the IPC bridge to the renderer process:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Simplified preload.js\ncontextBridge.exposeInMainWorld("Electron", {\n  // Other methods...\n\n  Api: (id, cmd, args) => {\n    id = Number(id) || 0;\n    cmd = String(cmd || "");\n    args = args || [];\n\n    let ret = new Promise(() => {});\n\n    try {\n      ret = ipcRenderer.invoke("Api", id, cmd, args).catch((error) => {\n        console.log(error);\n      });\n    } catch (e) {}\n\n    return ret;\n  },\n});\n'})}),"\n",(0,r.jsx)(n.h4,{id:"backend-ipc-implementation",children:"Backend IPC Implementation"}),"\n",(0,r.jsx)(n.p,{children:"The backend (anytype-heart) implements a gateway that receives commands from the frontend:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"// Simplified gateway implementation\npackage gateway\n\ntype gateway struct {\n  // Dependencies and state\n}\n\nfunc (g *gateway) HandleCommand(cmd string, args []interface{}) (interface{}, error) {\n  // Route the command to the appropriate service\n  // Return the result\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The backend communicates with the frontend through a compiled C library interface that uses Protocol Buffers for serialization:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// From clientlibrary/clib/main.go\n//export Command\nfunc Command(cmd *C.char, data unsafe.Pointer, dataLen C.int, callback C.proxyFunc, callbackContext unsafe.Pointer) {\n  service.CommandAsync(C.GoString(cmd), C.GoBytes(data, dataLen), func(data []byte) {\n    C.ProxyCall(callback, callbackContext, C.CString(""), C.CString(string(data)), C.int(len(data)))\n  })\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-command-pattern",children:"3. Command Pattern"}),"\n",(0,r.jsx)(n.p,{children:"The API layer in the frontend implements a command pattern, with each backend operation wrapped in a function:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Example command in command.ts\nexport const BlockSetFields = (\n  contextId: string,\n  blockId: string,\n  fields: any,\n  callBack?: (message: any) => void\n) => {\n  const request = new Rpc.Block.SetFields.Request();\n\n  request.setContextid(contextId);\n  request.setBlockid(blockId);\n  request.setFields(Encode.struct(fields || {}));\n\n  dispatcher.request(BlockSetFields.name, request, callBack);\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"Each command follows a consistent pattern:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Create a Protocol Buffer request object"}),"\n",(0,r.jsx)(n.li,{children:"Set parameters on the request"}),"\n",(0,r.jsx)(n.li,{children:"Send the request through the dispatcher"}),"\n",(0,r.jsx)(n.li,{children:"Optionally process the response in a callback"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-event-system",children:"4. Event System"}),"\n",(0,r.jsx)(n.p,{children:"The integration includes a sophisticated event system for bidirectional communication:"}),"\n",(0,r.jsx)(n.h4,{id:"event-dispatcher",children:"Event Dispatcher"}),"\n",(0,r.jsx)(n.p,{children:"The frontend implements a dispatcher that handles events from the backend:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Simplified dispatcher.ts\nclass Dispatcher {\n  service: Service.ClientCommandsClient = null;\n\n  // Event handler\n  event(event: Events.Event, skipDebug?: boolean) {\n    const { config, space } = S.Common;\n\n    // Process events and update stores accordingly\n    if (event && event.getMessagesList) {\n      event.getMessagesList().forEach((message) => {\n        const mapped = this.mapEvent(message);\n\n        switch (message.getPayloadCase()) {\n          case "BlockDataviewTargetObjectIdSet": {\n            const { id, targetObjectId } = mapped;\n            const block = S.Block.getLeaf(rootId, id);\n\n            if (!block) {\n              break;\n            }\n\n            S.Block.updateContent(rootId, id, { targetObjectId });\n            break;\n          }\n\n          // Other event handlers...\n        }\n      });\n    }\n  }\n\n  // Map event from Protocol Buffer to JavaScript object\n  mapEvent(message: any) {\n    // Use Mapper to convert Protocol Buffer to JavaScript object\n    return Mapper.From[message.getPayloadCase()](message.getPayload());\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"event-subscription",children:"Event Subscription"}),"\n",(0,r.jsx)(n.p,{children:"The backend sends events to the frontend through a subscription mechanism:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Example subscription in command.ts\nexport const ObjectSubscribeIds = (\n  spaceId: string,\n  subId: string,\n  ids: string[],\n  keys: string[],\n  noDeps: boolean,\n  callBack?: (message: any) => void\n) => {\n  const request = new Rpc.Object.SubscribeIds.Request();\n\n  request.setSpaceid(spaceId);\n  request.setSubid(subId);\n  request.setIdsList(ids);\n  request.setKeysList(keys);\n  request.setNodepsubscription(noDeps);\n\n  dispatcher.request(ObjectSubscribeIds.name, request, callBack);\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The backend uses gRPC streaming to send events back to the frontend, implemented through the ",(0,r.jsx)(n.code,{children:"ListenSessionEvents"})," method:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"// From pb/service/service.pb.go\nfunc (s *service) ListenSessionEvents(req *pb.StreamRequest, stream pb.ClientCommands_ListenSessionEventsServer) error {\n  // Setup event listener\n  // When events occur, send them to the frontend\n  return stream.Send(&pb.Event{\n    Messages: []*pb.Event_Message{\n      // Event messages\n    },\n  })\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This event streaming is critical for maintaining the reactive nature of the frontend UI."}),"\n",(0,r.jsx)(n.h3,{id:"5-data-mappers",children:"5. Data Mappers"}),"\n",(0,r.jsx)(n.p,{children:"To ensure consistent data structures, the frontend includes mappers for converting between Protocol Buffer objects and JavaScript objects:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Simplified mapper.ts\nexport const Mapper = {\n  // From backend to frontend\n  From: {\n    SubscriptionAdd: (obj: Events.Event.Object.Subscription.Add) => {\n      return {\n        id: obj.getId(),\n        afterId: obj.getAfterid(),\n        subId: obj.getSubid(),\n      };\n    },\n    // Other mappers...\n  },\n\n  // From frontend to backend\n  To: {\n    Filter: (filter: I.Filter) => {\n      const f = new Model.Filter();\n      f.setRelationkey(filter.relationKey);\n      f.setCondition(filter.condition);\n      f.setValue(Encode.value(filter.value));\n      return f;\n    },\n    // Other mappers...\n  },\n};\n"})}),"\n",(0,r.jsx)(n.h2,{id:"data-flow-examples",children:"Data Flow Examples"}),"\n",(0,r.jsx)(n.h3,{id:"1-creating-a-block",children:"1. Creating a Block"}),"\n",(0,r.jsx)(n.p,{children:"When creating a new block, the data flows as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1. User interacts with UI component\n2. Component calls store method (Block.add)\n3. Store calls API method (BlockCreate)\n4. API constructs Protocol Buffer request\n5. Request sent via IPC to backend\n6. Backend processes request and applies changes\n7. Backend sends events back to frontend\n8. Frontend dispatcher processes events\n9. Store updates based on events\n10. UI reacts to store changes\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-subscribing-to-object-changes",children:"2. Subscribing to Object Changes"}),"\n",(0,r.jsx)(n.p,{children:"To monitor changes to objects:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1. Store calls API method (ObjectSubscribeIds)\n2. API constructs subscription request\n3. Request sent via IPC to backend\n4. Backend sets up subscription\n5. When changes occur, backend sends events\n6. Frontend dispatcher processes events\n7. Store updates based on events\n8. UI reacts to store changes\n"})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.p,{children:"The integration includes robust error handling:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"IPC Communication Errors"}),": Caught and logged at the IPC layer"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Command Validation Errors"}),": Validated in both frontend and backend"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Business Logic Errors"}),": Returned as structured error responses"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Event Processing Errors"}),": Isolated to prevent cascading failures"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Error handling is implemented on both sides of the integration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Frontend error handling\ntry {\n  const result = await renderer.send("Command", args);\n  // Process result\n} catch (error) {\n  console.error("Command failed:", error);\n  // Handle error, update UI, show notification, etc.\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Backend error handling\nfunc (g *gateway) HandleCommand(cmd string, args []interface{}) (interface{}, error) {\n  // Validate command and arguments\n  if !isValidCommand(cmd) {\n    return nil, errors.New("invalid command")\n  }\n\n  // Handle command\n  result, err := g.executeCommand(cmd, args)\n  if err != nil {\n    log.Error("Command execution failed", err)\n    return nil, err\n  }\n\n  return result, nil\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(n.p,{children:"The integration is optimized for performance:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Batched Operations"}),": Multiple changes sent in a single request"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Selective Updates"}),": Only changed data is sent over IPC"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Event Filtering"}),": Events are filtered based on subscriptions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lazy Loading"}),": Data is loaded only when needed"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"integration-with-sync-infrastructure",children:"Integration with Sync Infrastructure"}),"\n",(0,r.jsx)(n.p,{children:"The frontend-backend integration interfaces with the synchronization infrastructure to provide multi-device capabilities:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Local-First"}),": All operations are first applied locally through the backend"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Background Sync"}),": Backend handles synchronization with other devices in the background"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Conflict Resolution"}),": The CRDT implementation in the backend handles conflicts automatically"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sync Status Events"}),": Backend sends sync status updates to the frontend through the event system"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The sync status is tracked and displayed in the UI:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Example sync status subscription\nexport const SyncGetStatus = (callBack?: (message: any) => void) => {\n  const request = new Rpc.Sync.GetStatus.Request();\n  dispatcher.request(SyncGetStatus.name, request, callBack);\n};\n"})}),"\n",(0,r.jsx)(n.h2,{id:"key-insights",children:"Key Insights"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Clear Separation of Concerns"}),": The frontend focuses on UI and state management, while the backend handles business logic and data persistence."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Protocol Buffer Foundation"}),": Protocol Buffers provide a consistent data format between frontend and backend."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Event-Driven Architecture"}),": The system uses an event-driven approach for updating the UI in response to backend changes."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Command Pattern"}),": The API layer implements a command pattern for clearly defined operations."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Bidirectional Communication"}),": The integration supports both request-response and event-based communication."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Local Integration"}),": The backend is embedded within the frontend application, enabling offline-first operation."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Abstraction Layers"}),": Multiple abstraction layers (API, Mappers, Stores) ensure clean separation and maintainable code."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This architecture enables Anytype to function as a cohesive application while maintaining a clean separation between frontend and backend concerns, facilitating maintainability and enabling the offline-first approach that is central to Anytype's design philosophy."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);